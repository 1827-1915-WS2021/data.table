require(methods)

if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  smerge = data.table:::smerge
  bmerge = data.table:::bmerge
  forderv = data.table:::forderv
}

bm = function(x, y) {
  stopifnot(is.integer(x), is.integer(y))
  ans = bmerge(data.table(x=x), data.table(y=y), 1L, 1L, roll=0, rollends=c(FALSE, TRUE), nomatch=NA_integer_, mult="all", ops=1L, verbose=FALSE)
  ## if undefining SMERGE_STATS then we have to ignore allLen1 as well
  ans
}
sm = function(x, y) {
  stopifnot(is.integer(x), is.integer(y))
  ans = smerge(x, y, out.bmerge=TRUE)
  ## if undefining SMERGE_STATS then we have to ignore allLen1 as well
  ans
}

#options(datatable.verbose=TRUE)

## x y sorted
x = c(1L,2L,3L,4L)
y = c(2L,3L,5L)
test(1.01, sm(x, y), bm(x, y))
x = c(1L,2L,3L,3L,4L)
y = c(2L,3L,5L)
test(1.02, sm(x, y), bm(x, y))
x = c(1L,2L,3L,4L)
y = c(2L,3L,3L,5L)
test(1.03, sm(x, y), bm(x, y))
x = c(1L,2L,3L,3L,4L)
y = c(2L,3L,3L,5L)
test(1.04, sm(x, y), bm(x, y))

## y unsorted
x = c(1L,2L,3L,4L)
y = c(2L,5L,3L)
test(2.01, sm(x, y), bm(x, y))
x = c(1L,2L,3L,3L,4L)
y = c(3L,2L,5L)
test(2.02, sm(x, y), bm(x, y))
x = c(1L,2L,3L,4L)
y = c(5L,3L,2L,3L)
test(2.03, sm(x, y), bm(x, y))
x = c(1L,2L,3L,3L,4L)
y = c(5L,3L,3L,2L)
test(2.04, sm(x, y), bm(x, y))

#...

## xy unsorted
x = c(4L,1L,3L,2L)
y = c(2L,5L,3L)
test(4.01, sm(x, y), bm(x, y))

#...

## xy sorted
ssa = function(unq_n, size, sort=FALSE) {
  stopifnot(unq_n <= size)
  unq_sub = seq_len(unq_n)
  ans = sample(c(unq_sub, sample(unq_sub, size=max(size-unq_n, 0), replace=TRUE)))
  if (unq_n==size) stopifnot(uniqueN(ans)==length(ans))
  if (sort) sort(ans) else ans
}
N = 1e2L
x = ssa(N, N, sort=TRUE)
y = ssa(N, N, sort=TRUE)
test(11.01, sm(x, y), bm(x, y))
x = ssa(N, N*1.1, sort=TRUE)
y = ssa(N, N, sort=TRUE)
test(11.02, sm(x, y), bm(x, y))
x = ssa(N, N, sort=TRUE)
y = ssa(N, N*1.1, sort=TRUE)
test(11.03, sm(x, y), bm(x, y))
x = ssa(N, N*1.1, sort=TRUE)
y = ssa(N, N*1.1, sort=TRUE)
test(11.04, sm(x, y), bm(x, y))

## y unsorted
x = ssa(N, N, sort=TRUE)
y = ssa(N, N)
test(12.01, sm(x, y), bm(x, y))
x = ssa(N, N*1.1, sort=TRUE)
y = ssa(N, N)
test(12.02, sm(x, y), bm(x, y))
x = ssa(N, N, sort=TRUE)
y = ssa(N, N*1.1)
test(12.03, sm(x, y), bm(x, y))
x = ssa(N, N*1.1, sort=TRUE)
y = ssa(N, N*1.1)
test(12.04, sm(x, y), bm(x, y))

## xy unsorted
x = ssa(N, N)
y = ssa(N, N)
test(14.01, sm(x, y), bm(x, y))
x = ssa(N, N*1.1)
y = ssa(N, N)
test(14.02, sm(x, y), bm(x, y))
x = ssa(N, N)
y = ssa(N, N*1.1)
test(14.03, sm(x, y), bm(x, y))
x = ssa(N, N*1.1)
y = ssa(N, N*1.1)
test(14.04, sm(x, y), bm(x, y))

# sparse
x = sample(2e2L, 1e2L) ## may fail when no matches!
y = sample(2e2L, 1e2L)
test(21.01, sm(x, y), bm(x, y))
x = sample(2e2L, 1e2L, TRUE)
y = sample(2e2L, 1e2L, TRUE)
test(21.02, sm(x, y), bm(x, y))

d1 = data.table(x=x, v1=seq_along(x))
d2 = data.table(y=y, v2=seq_along(y))
options(datatable.smerge=FALSE, datatable.verbose=TRUE) ## verbose=2L after #4491
test(101.01, expected <- d1[d2, on="x==y"], output="bmerge", notOutput="smerge")
options(datatable.smerge=TRUE)
test(101.02, d1[d2, on="x==y"], expected, output="smerge") ## for now extra computation of bmerge is still done so no: #, notOutput="bmerge")

setindexv2 = function(x, cols) { ## pretend we are after #4386
  stopifnot(is.data.table(x), is.character(cols))
  if (is.null(attr(x, "index", TRUE))) setattr(x, "index", integer())
  setattr(attr(x, "index", TRUE), paste0("__", cols, collapse="__"), forderv(x, cols, retGrp=TRUE))
  invisible(x)
}
setindexv2(d1, "x")
setindexv2(d2, "y")
test(101.03, d1[d2, on="x==y"], expected, output="smerge.*already indexed")
options(datatable.use.index=FALSE)
test(101.04, d1[d2, on="x==y"], expected, output="smerge", notOutput="already indexed")
