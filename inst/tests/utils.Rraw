require(methods)
if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if (!identical(suppressWarnings(packageDescription("data.table")), NA)) {
    remove.packages("data.table")
    stop("This is dev mode but data.table was installed. Uninstalled it. Please q() this R session and try cc() again. The installed namespace causes problems in dev mode for the S4 tests.\n")
  }
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  colnamesInt = data.table:::colnamesInt
  coerceClass = data.table:::coerceClass
}

sugg = c(
  "bit64",
  "nanotime"
)
for (s in sugg) {
  assign(paste0("test_",s), loaded<-suppressWarnings(suppressMessages(require(s, character.only=TRUE))))
  if (!loaded) cat("\n**** Suggested package",s,"is not installed. Tests using it will be skipped.\n\n")
}

# colnamesInt helper
dt = data.table(a=1, b=2, d=3)
test(4.01, colnamesInt(dt, "a"), 1L)
test(4.02, colnamesInt(dt, 1L), 1L)
test(4.03, colnamesInt(dt, 1), 1L)
test(4.04, colnamesInt(dt, c("a","d")), c(1L, 3L))
test(4.05, colnamesInt(dt, c(1L, 3L)), c(1L, 3L))
test(4.06, colnamesInt(dt, c(1, 3)), c(1L, 3L))
test(4.07, colnamesInt(dt, c("a", "e")), error="specify non existing column*.*e")
test(4.08, colnamesInt(dt, c(1L, 4L)), error="specify non existing column*.*4")
test(4.09, colnamesInt(dt, c(1, 4)), error="specify non existing column*.*4")
test(4.10, colnamesInt(dt, c("a", NA)), error="specify non existing column*.*NA")
test(4.11, colnamesInt(dt, c(1L, NA)), error="specify non existing column")
test(4.12, colnamesInt(dt, c(1, NA)), error="specify non existing column")
test(4.13, colnamesInt(dt, c("a","d","a"), check_dups=TRUE), error="specify duplicated column")
test(4.14, colnamesInt(dt, c(1L, 3L, 1L), check_dups=TRUE), error="specify duplicated column")
test(4.15, colnamesInt(dt, c(1, 3, 1), check_dups=TRUE), error="specify duplicated column")
test(4.16, colnamesInt(dt, list("a")), error="must be character or numeric")
test(4.17, colnamesInt(dt, NA), error="must be character or numeric")
test(4.18, colnamesInt(dt, character()), integer())
test(4.19, colnamesInt(dt, numeric()), integer())
test(4.20, colnamesInt(dt, integer()), integer())
test(4.21, colnamesInt(dt, NULL), seq_along(dt))
test(4.22, colnamesInt("asd", 1), error="must be data.table compatible")
test(4.23, colnamesInt(dt, 1, check_dups="a"), error="check_dups")
names(dt) <- NULL
test(4.24, colnamesInt(dt, "a"), error="has no names")

# coerceClass verbose
op = options(datatable.verbose=TRUE)
test(5.01, coerceClass("0", list(integer(0))), list(0L), output="unknown to integer using coerceVector")
test(5.02, coerceClass(0L, list(integer(0))), list(0L), output="integer to integer using memcpy")
test(5.03, coerceClass(structure(0, class="integer64"), list(integer(0))), list(0L), output="long long to integer using loop")
test(5.04, coerceClass(0, list(integer(0))), list(0L), output="double to integer using loop")
test(5.05, coerceClass("0", list(double(0))), list(0), output="unknown to double using coerceVector")
test(5.06, coerceClass("0", list(structure(double(0), class="integer64"))), list(structure(0, class="integer64")), output="unknown to long long using coerceVector")
test(5.07, coerceClass(0L, list(double(0))), list(0), output="integer to double using loop")
test(5.08, coerceClass(0L, list(structure(double(0), class="integer64"))), list(structure(0, class="integer64")), output="integer to long long using loop")
test(5.09, coerceClass(0, list(double(0))), list(0), output="double to double using memcpy")
test(5.10, coerceClass(0, list(structure(double(0), class="integer64"))), list(structure(0, class="integer64")), output="double to long long using loop")
test(5.11, coerceClass(structure(0, class="integer64"), list(double(0))), list(0), output="long long to double using loop")
test(5.12, coerceClass(structure(0, class="integer64"), list(structure(double(0), class="integer64"))), list(structure(0, class="integer64")), output="long long to long long using memcpy")
test(5.13, coerceClass("0", list(complex(0))), list(0+0i), output="unknown to unknown using coerceVector")
options(op)
# coerceClass atomic out
test(5.21, coerceClass(0L, integer(0)), 0L)
test(5.22, coerceClass(0L, double(0)), 0)
test(5.23, coerceClass(0, integer(0)), 0L)
test(5.24, coerceClass(0, double(0)), 0)
# coerceClass list out
test(5.31, coerceClass(0L, list(integer(0), double(0))), list(0L, 0))
test(5.32, coerceClass(0L, list(double(0), double(0))), list(0, 0))
test(5.33, coerceClass(0, list(integer(0), integer(0))), list(0L, 0L))
test(5.34, coerceClass(0, list(double(0), integer(0))), list(0, 0L))
# coerceClass vector x
test(5.41, coerceClass(1:3, integer(0)), 1:3)
test(5.42, coerceClass(1:3, double(0)), c(1,2,3))
test(5.43, coerceClass(c(1,2,3), integer(0)), 1:3)
test(5.44, coerceClass(c(1,2,3), double(0)), c(1,2,3))
# coerceClass vector x list out
test(5.51, coerceClass(1:3, list(integer(0), double(0))), list(1:3, c(1,2,3)))
test(5.52, coerceClass(1:3, list(double(0), double(0))), list(c(1,2,3), c(1,2,3)))
test(5.53, coerceClass(c(1,2,3), list(integer(0), integer(0))), list(1:3, 1:3))
test(5.54, coerceClass(c(1,2,3), list(double(0), integer(0))), list(c(1,2,3), 1:3))

# int32 range
# int64 range
# matrix, array
# nanotime, int64-nanotime, nanotime-int64
# factor
# character
# list

if (test_bit64) {
  out = list(0L, 0, as.integer64(0)) # test ported from old coerceFill, used in nafill
  test(6.01, identical(coerceClass(1:2, out), list(1:2, c(1,2), as.integer64(1:2))))
  test(6.02, coerceClass(0+0i, out), list(0L, 0, as.integer64(0)))
  test(6.11, identical(coerceClass(NA, out), list(NA_integer_, NA_real_, as.integer64(NA))))
  test(6.21, identical(coerceClass(3L, out), list(3L, 3, as.integer64(3))))
  test(6.22, identical(coerceClass(0L, out), list(0L, 0, as.integer64(0))))
  test(6.23, identical(coerceClass(NA_integer_, out), list(NA_integer_, NA_real_, as.integer64(NA))))
  test(6.31, identical(coerceClass(as.integer64(3), out), list(3L, 3, as.integer64(3))))
  test(6.32, identical(coerceClass(as.integer64(3000000003), out), list(NA_integer_, 3000000003, as.integer64("3000000003"))))
  test(6.33, identical(coerceClass(as.integer64(0), out), list(0L, 0, as.integer64(0))))
  test(6.34, identical(coerceClass(as.integer64(NA), out), list(NA_integer_, NA_real_, as.integer64(NA))))
  test(6.41, identical(coerceClass(3, out), list(3L, 3, as.integer64(3))))
  test(6.42, identical(coerceClass(0, out), list(0L, 0, as.integer64(0))))
  test(6.43, identical(coerceClass(NA_real_, out), list(NA_integer_, NA_real_, as.integer64(NA))))
  test(6.44, identical(coerceClass(NaN, out), list(NA_integer_, NaN, as.integer64(NA))))
  test(6.45, identical(coerceClass(Inf, out), list(NA_integer_, Inf, as.integer64(NA))))
  test(6.46, identical(coerceClass(-Inf, out), list(NA_integer_, -Inf, as.integer64(NA))))
}
