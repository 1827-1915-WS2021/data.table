require(methods)

if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  mergepair = data.table:::mergepair
}

addresses = function(x) vapply(x, address, "")
noCopy = function(ans, lhs, rhs) all(!addresses(ans) %chin% c(addresses(lhs), addresses(rhs)))
lhsCopy = function(ans, lhs) if (nrow(lhs)) all(addresses(lhs) %chin% addresses(ans)) else TRUE
rhsNoCopy = function(ans, rhs) if (nrow(rhs)) all(!addresses(rhs) %chin% addresses(ans)) else TRUE
test.copy = function(ans, lhs, rhs, how, copy, should=character(), shouldnot=character()) {
  if (isTRUE(copy)) return(noCopy(ans, lhs, rhs))
  if (how=="right") { tmp=lhs; lhs=rhs; rhs=tmp; rm(tmp) } ## handle right join swap
  if (how %in% shouldnot) return(!noCopy(ans, lhs, rhs))
  if (how %in% should) return(noCopy(ans, lhs, rhs))
  if (!is.na(copy)) return(lhsCopy(ans, lhs) && rhsNoCopy(ans, rhs))
  return(lhsCopy(ans, lhs))
}

# cbindlist

l = list(
  d1 = data.table(x=1:3, v1=1L),
  d2 = data.table(y=3:1, v2=2L),
  d3 = data.table(z=2:4, v3=3L)
)
ans = cbindlist(l)
expected = data.table(l$d1, l$d2, l$d3)
test(11.01, ans, expected)
test(11.02, intersect(addresses(ans), addresses(expected)), character())
ans = cbindlist(l, copy=FALSE)
expected = setDT(c(l$d1, l$d2, l$d3))
test(11.03, ans, expected)
test(11.04, length(intersect(addresses(ans), addresses(expected))), ncol(expected))
# codecov
test(12.01, cbindlist(data.frame(a=1L), data.frame(b=1L)), error="must be a list")
test(12.02, cbindlist(TRUE, FALSE), error="must be a list")
test(12.03, cbindlist(list(), NA), error="must be TRUE or FALSE")
test(12.04, cbindlist(list(data.table(a=1L), 1L)), error="is not of data.table type")
test(12.05, cbindlist(list(data.table(a=1L), data.table(b=1:2)), copy=FALSE), error="has to have equal nrow")
test(12.06, cbindlist(list(data.table(a=1L), data.table(b=1:2))), error="recycling.*not yet implemented")
op = options(datatable.verbose=TRUE)
test(12.07, cbindlist(list(data.table(a=1:2), data.table(b=1:2))), data.table(a=1:2, b=1:2), output="cbindlist.*took")
options(op)
rm(expected)

# mergepair

## test copy-ness argument, in mergepair copyness if always for join-from table, not always lhs, in mergepair copy!=TRUE will only be allowed for how='left' so lhs=join-from holds, that is why swap tables in test.copy

### LHS equal to RHS: no copy in all cases
num = 21.000
l = list(
  lhs = data.table(id1=1:2, v1=1:2),
  rhs = data.table(id1=1:2, v2=1:2)
)
expected = list(id1=1:2, v1=1:2, v2=1:2)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected)
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected)
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected)
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA))
  }
}

### RHS includes LHS: no copy in inner, left, right
num = 22.000
should = "full"
l = list(
  lhs = data.table(id1=1:2, v1=1:2),
  rhs = data.table(id1=1:3, v2=1:3)
)
expected = list(
  inner = list(id1=1:2, v1=1:2, v2=1:2),
  left = list(id1=1:2, v1=1:2, v2=1:2),
  right = list(id1=1:3, v1=c(1:2,NA), v2=1:3),
  full = list(id1=1:3, v1=c(1:2,NA), v2=1:3)
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should=should))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, should=should))
  }
}

### LHS includes RHS: no copy in left, right, full
num = 23.000
should = "inner"
l = list(
  lhs = data.table(id1=1:3, v1=1:3),
  rhs = data.table(id1=1:2, v2=1:2)
)
expected = list(
  inner = list(id1=1:2, v1=1:2, v2=1:2),
  left = list(id1=1:3, v1=1:3, v2=c(1:2,NA)),
  right = list(id1=1:2, v1=1:2, v2=1:2),
  full = list(id1=1:3, v1=1:3, v2=c(1:2,NA))
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should=should))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, should=should))
  }
}

### LHS single nonmatch RHS on both sides: no copy in left, right
num = 24.000
should = c("inner","full")
l = list(
  lhs = data.table(id1=3:1, v1=1:3),
  rhs = data.table(id1=c(4L,2:1), v2=1:3)
)
expected = list(
  inner = list(id1=2:1, v1=2:3, v2=2:3),
  left = list(id1=3:1, v1=1:3, v2=c(NA,2:3)),
  right = list(id1=c(4L,2:1), v1=c(NA,2:3), v2=1:3),
  full = list(id1=c(3:1,4L), v1=c(1:3,NA), v2=c(NA,2:3,1L))
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should=should))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, should=should))
  }
}

### LHS zero match RHS: no copy in left, right
num = 25.000
should = c("inner","full")
l = list(
  lhs = data.table(id1=2:1, v1=1:2),
  rhs = data.table(id1=3:4, v2=1:2)
)
expected = list(
  inner = list(id1=integer(), v1=integer(), v2=integer()),
  left = list(id1=2:1, v1=1:2, v2=c(NA_integer_,NA)),
  right = list(id1=3:4, v1=c(NA_integer_,NA), v2=1:2),
  full = list(id1=c(2:1,3:4), v1=c(1:2,NA,NA), v2=c(NA,NA,1:2))
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should=should))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, should=should))
  }
}

### LHS and RHS zero nrow: no copies
num = 26.000
should = character()
l = list(
  lhs = data.table(id1=integer(), v1=integer()),
  rhs = data.table(id1=integer(), v2=integer())
)
expected = list(
  inner = list(id1=integer(), v1=integer(), v2=integer()),
  left = list(id1=integer(), v1=integer(), v2=integer()),
  right = list(id1=integer(), v1=integer(), v2=integer()),
  full = list(id1=integer(), v1=integer(), v2=integer())
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should=should))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, should=should))
  }
}

### LHS has zero nrow
num = 27.000
l = list(
  lhs = data.table(id1=integer(), v1=integer()),
  rhs = data.table(id1=2:1, v2=1:2)
)
expected = list(
  inner = list(id1=integer(), v1=integer(), v2=integer()),
  left = list(id1=integer(), v1=integer(), v2=integer()),
  right = list(id1=2:1, v1=c(NA_integer_,NA), v2=1:2),
  full = list(id1=2:1, v1=c(NA_integer_,NA), v2=1:2)
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should="full")) ## rhs should be copied here, because copy=F copy rhs
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, shouldnot="full")) ## rhs is identical, does not need to be copied
  }
}

### RHS has zero nrow: copy inner
num = 28.000
should = "inner"
l = list(
  lhs = data.table(id1=2:1, v1=1:2),
  rhs = data.table(id1=integer(), v2=integer())
)
expected = list(
  inner = list(id1=integer(), v1=integer(), v2=integer()),
  left = list(id1=2:1, v1=1:2, v2=c(NA_integer_,NA)),
  right = list(id1=integer(), v1=integer(), v2=integer()),
  full = list(id1=2:1, v1=1:2, v2=c(NA_integer_,NA))
)
for (how in c("inner","left","right","full")) {
  num = trunc(num*10)/10 + 0.1
  for (mult in c("all","first","last","error")) {
    num = trunc(num*100)/100 + 0.01
    ## copy=TRUE: no shared columns
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
    ## copy=FALSE: LHS shared but no RHS
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE, should=should))
    ## copy=NA: at least LHS shared
    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected[[how]])
    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA, should=should))
  }
}

# mergelist

## no duplicates

### LHS equal to RHS
#num = 121.000
#l = list(
#  lhs = data.table(id1=1:2, v1=1:2),
#  rhs = data.table(id1=1:2, v2=1:2)
#)
#expected = list(id1=1:2, v1=1:2, v2=1:2)
#for (how in c("inner","left","right","full")) {
#  num = trunc(num*10)/10 + 0.1
#  for (mult in c("all","first","last","error")) {
#    num = trunc(num*100)/100 + 0.01
#    ## copy=TRUE: no shared columns
#    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=TRUE), expected)
#    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=TRUE))
#    ## copy=FALSE: LHS shared but no RHS
#    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=FALSE), expected)
#    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=FALSE))
#    ## copy=NA: at least LHS shared
#    test(num<-num+0.001, ans <- mergepair(l$lhs, l$rhs, on="id1", how=how, mult=mult, copy=NA), expected)
#    test(num<-num+0.001, test.copy(ans, l$lhs, l$rhs, how=how, copy=NA))
#  }
#}

## duplicate matches, those tests have matching tests vs SQLite

### duplicates in RHS and LHS
num = 221.00
l = list(
  lhs = data.table(id1=c(1:3,3L), v1=1:4),
  rhs = data.table(id1=c(1L,1L,3:4), v2=1:4)
)
expected = list(
  inner = list(
    all = data.table(id1=c(1L,1L,3L,3L), v1=c(1L,1L,3L,4L), v2=c(1:3,3L)),
    first = data.table(id1=c(1L,3L), v1=c(1L,3L), v2=c(1L,3L)),
    last = data.table(id1=c(1L,3L), v1=c(1L,4L), v2=2:3),
    error = NULL
  ),
  left = list(
    all = data.table(id1=c(1L,1:3,3L), v1=c(1L,1:4), v2=c(1:2,NA,3L,3L)),
    first = data.table(id1=c(1:3,3L), v1=1:4, v2=c(1L,NA,3L,3L)),
    last = data.table(id1=c(1:3,3L), v1=1:4, v2=c(2L,NA,3L,3L)),
    error = NULL
  ),
  right = list(
    all = data.table(id1=c(1L,1L,3L,3:4), v1=c(1L,1L,3:4,NA), v2=c(1:3,3:4)),
    first = data.table(id1=c(1L,1L,3:4), v1=c(1L,1L,3L,NA), v2=1:4),
    last = data.table(id1=c(1L,1L,3:4), v1=c(1L,1L,4L,NA), v2=1:4),
    error = NULL
  ),
  full = list(
    all = data.table(id1=c(1L,1:3,3:4), v1=c(1L,1:4,NA), v2=c(1:2,NA,3L,3:4)),
    first = data.table(id1=1:4, v1=c(1:3,NA), v2=c(1L,NA,3:4)),
    last = data.table(id1=1:4, v1=c(1:2,4L,NA), v2=c(2L,NA,3:4)),
    error = NULL
  )
)
#for (how in c("inner","left","right","full")) {
#  num = trunc(num*10)/10 + 0.1
#  for (mult in c("all","first","last","error")) {
#    num = trunc(num*100)/100 + 0.01
#    if (is.null(expected[[how]][[mult]])) {
#      test(num, mergelist(l, on="id1", how=how, mult=mult), error="multiple matches during merge")
#    } else {
#      test(num, mergelist(l, on="id1", how=how, mult=mult), expected[[how]][[mult]])
#    }
#  }
#}

## test exceeding overalloc for a table

## SQLite reference tests can be launched via

### Rscript -e 'install.packages(c("DBI","RSQLite"), repos="https://jangorecki.gitlab.io/rsqlite")'
### Rscript inst/tests/sqlite.R
